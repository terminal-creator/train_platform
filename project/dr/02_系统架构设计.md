# 模块二：系统架构设计

> Agent执行框架、工具集设计、状态管理与记忆机制的深度解析

---

## 1. Agent 执行框架

### 1.1 从传统问答到 Agent 范式

传统的LLM问答是一次性的输入-输出过程：

```
Input (Question) → LLM → Output (Answer)
```

Agent范式引入了与环境的交互循环：

```
Input → LLM → Action → Environment → Observation → LLM → Action → ... → Output
```

**为什么需要Agent范式？**

| 场景 | 传统LLM的局限 | Agent的解决方案 |
|------|---------------|-----------------|
| 信息不在训练数据中 | 无法回答或幻觉 | 实时搜索获取 |
| 需要精确计算 | 计算能力有限 | 调用Python执行 |
| 信息分布在多个来源 | 无法整合 | 多轮搜索和访问 |
| 任务需要多步推理 | 一次生成难以完成 | 迭代推理和执行 |

### 1.2 ReAct 框架详解

ReAct（Reasoning and Acting）是最基础也是最广泛使用的Agent框架。

#### 1.2.1 核心思想

ReAct的核心是将**推理（Reasoning）**和**行动（Acting）**交织在一起：

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           ReAct 核心循环                                         │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│                              ┌─────────┐                                        │
│                              │  输入   │                                        │
│                              │ Question│                                        │
│                              └────┬────┘                                        │
│                                   │                                             │
│                                   ▼                                             │
│    ┌──────────────────────────────────────────────────────────┐                │
│    │                                                          │                │
│    │  ┌─────────────────────────────────────────────────┐    │                │
│    │  │         Step 1: Think (推理)                     │    │                │
│    │  │  分析当前状态，决定下一步行动                      │    │                │
│    │  │  "我需要搜索X来回答这个问题"                       │    │                │
│    │  └─────────────────────────────────────────────────┘    │                │
│    │                          │                               │                │
│    │                          ▼                               │                │
│    │  ┌─────────────────────────────────────────────────┐    │                │
│    │  │         Step 2: Action (行动)                    │    │                │
│    │  │  执行具体的工具调用                               │    │                │
│    │  │  search("X相关查询")                              │    │                │
│    │  └─────────────────────────────────────────────────┘    │                │
│    │                          │                               │                │
│    │                          ▼                               │                │
│    │  ┌─────────────────────────────────────────────────┐    │                │
│    │  │         Step 3: Observation (观察)               │    │                │
│    │  │  接收工具执行结果                                 │    │                │
│    │  │  "搜索返回了以下结果..."                          │    │                │
│    │  └─────────────────────────────────────────────────┘    │                │
│    │                          │                               │                │
│    │                          ▼                               │                │
│    │              信息足够回答问题？                          │                │
│    │                    │     │                               │                │
│    │                 否 │     │ 是                            │                │
│    │                    │     │                               │                │
│    │    ┌───────────────┘     └───────────────┐              │                │
│    │    │                                     │              │                │
│    │    ▼                                     ▼              │                │
│    │  返回Step 1                        生成最终答案          │                │
│    │  继续迭代                                               │                │
│    │                                                          │                │
│    └──────────────────────────────────────────────────────────┘                │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

#### 1.2.2 消息格式设计

ReAct使用特定的标签来区分不同类型的内容：

```xml
<!-- 系统提示 -->
<system>
你是一个研究助手，能够使用以下工具来回答问题：
- search: 搜索互联网
- visit: 访问网页获取详细内容
- python: 执行Python代码

请按照以下格式回答：
1. 先思考需要做什么
2. 然后调用工具
3. 根据结果继续思考或给出答案
</system>

<!-- 用户问题 -->
<user>
法国2024年的GDP是多少？与2023年相比增长了多少？
</user>

<!-- Assistant 第一轮 -->
<assistant>
<think>
用户询问法国2024年的GDP及其增长率。这需要两个数据点：
1. 法国2024年的GDP
2. 法国2023年的GDP（用于计算增长率）

让我先搜索法国2024年的GDP数据。
</think>
<tool_call>
{"name": "search", "arguments": {"query": "France GDP 2024"}}
</tool_call>
</assistant>

<!-- 工具返回 -->
<user>
<tool_response>
1. France GDP 2024 - World Bank
   France's GDP reached $3.03 trillion in 2024...
2. French Economy 2024 Statistics
   The French economy showed modest growth...
...
</tool_response>
</user>

<!-- Assistant 第二轮 -->
<assistant>
<think>
搜索结果显示法国2024年GDP约为3.03万亿美元。
现在我需要获取2023年的数据来计算增长率。
</think>
<tool_call>
{"name": "search", "arguments": {"query": "France GDP 2023"}}
</tool_call>
</assistant>

<!-- ... 继续迭代 ... -->

<!-- 最终答案 -->
<assistant>
<think>
现在我有了所有需要的数据：
- 2024年GDP：3.03万亿美元
- 2023年GDP：2.93万亿美元
- 增长率：(3.03-2.93)/2.93 = 3.4%
</think>
<answer>
法国2024年的GDP约为3.03万亿美元。与2023年的2.93万亿美元相比，
增长了约3.4%（即增加了约1000亿美元）。
</answer>
</assistant>
```

#### 1.2.3 ReAct 的优势与局限

**优势**：

| 优势 | 说明 |
|------|------|
| 简单直观 | 思考-行动-观察的循环易于理解和实现 |
| 可解释性强 | 每步推理都有明确的思考过程 |
| 灵活性高 | 可以根据观察结果动态调整策略 |
| 通用性好 | 适用于各种需要工具使用的任务 |

**局限**：

| 局限 | 原因 | 影响 |
|------|------|------|
| 上下文溢出 | 历史信息持续累积 | 长任务无法完成 |
| 错误累积 | 早期错误持续影响后续决策 | 降低任务成功率 |
| 信息噪声 | 无关的observation持续占用上下文 | 推理能力下降 |
| 效率问题 | 每步都需要处理完整历史 | 计算成本高 |

### 1.3 IterResearch 框架详解

IterResearch 是针对 Deep Research 任务设计的高级框架，专门解决 ReAct 在长horizon任务中的问题。

#### 1.3.1 核心创新：马尔可夫决策过程建模

IterResearch 将深度研究建模为**马尔可夫决策过程（MDP）**，关键创新是：

- **演进报告（Evolving Report）**作为中央记忆
- 每轮只保留**固定大小的状态空间**
- 丢弃临时信息，避免上下文污染

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                    IterResearch vs ReAct 对比                                    │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  ReAct (累积式):                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  Round 1: [Q, T₁, A₁, O₁]                                                │   │
│  │  Round 2: [Q, T₁, A₁, O₁, T₂, A₂, O₂]                                    │   │
│  │  Round 3: [Q, T₁, A₁, O₁, T₂, A₂, O₂, T₃, A₃, O₃]                        │   │
│  │  ...                                                                      │   │
│  │  Round N: [Q, T₁, A₁, O₁, ..., Tₙ, Aₙ, Oₙ]  ← 上下文线性增长！           │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  IterResearch (常量式):                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  Round 1: [Q, R₀(空), A₀, O₀] → 生成 R₁                                  │   │
│  │  Round 2: [Q, R₁,     A₁, O₁] → 生成 R₂                                  │   │
│  │  Round 3: [Q, R₂,     A₂, O₂] → 生成 R₃                                  │   │
│  │  ...                                                                      │   │
│  │  Round N: [Q, Rₙ₋₁,   Aₙ₋₁, Oₙ₋₁] → 生成 Rₙ  ← 上下文大小恒定！          │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  其中:                                                                          │
│  - Q: 原始问题                                                                  │
│  - T: Think (思考)                                                              │
│  - A: Action (动作)                                                             │
│  - O: Observation (观察结果)                                                    │
│  - R: Report (演进报告) - 包含了所有历史信息的压缩表示                          │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

#### 1.3.2 状态定义与转移

**形式化定义**：

```
MDP = (S, A, T, R, γ)

其中:
- S (状态空间): s_i = (q, Report_{i-1}, Action_{i-1}, Observation_{i-1})
- A (动作空间): {search, visit, scholar, python, final_answer}
- T (转移函数): 执行动作后获得观察结果，更新状态
- R (奖励函数): 基于最终答案正确性
- γ (折扣因子): 通常设为1（任务导向）
```

**状态转移过程**：

```python
class IterResearchState:
    def __init__(self, question: str):
        self.question = question
        self.report = ""  # 初始报告为空
        self.last_action = None
        self.last_observation = None

    def get_workspace(self) -> str:
        """构建当前工作空间"""
        workspace = f"Question: {self.question}\n\n"
        workspace += f"Current Report:\n{self.report}\n\n"

        if self.last_action:
            workspace += f"Last Action: {self.last_action}\n"
            workspace += f"Observation: {self.last_observation}\n"

        return workspace

    def transition(self, think: str, new_report: str,
                   action: Action, observation: str):
        """状态转移"""
        # 关键：丢弃think，只保留report
        self.report = new_report
        self.last_action = action
        self.last_observation = observation
```

#### 1.3.3 演进报告的设计

演进报告是 IterResearch 的核心，它需要：

1. **信息完整性**：包含所有已发现的关键信息
2. **结构清晰性**：便于模型理解和更新
3. **大小可控性**：不能无限增长

**报告模板示例**：

```markdown
## 研究报告

### 1. 问题分析
[对原始问题的理解和分解]

### 2. 已确认信息
- 信息点1: [来源: URL]
- 信息点2: [来源: URL]
- ...

### 3. 待验证信息
- 待验证点1: [需要进一步搜索]
- ...

### 4. 信息缺口
- 还需要: [描述需要但未获得的信息]

### 5. 当前结论
[基于已有信息的初步结论]

### 6. 下一步计划
[下一步应该做什么]
```

#### 1.3.4 完整执行流程

```python
def iterresearch_execute(model, question, tools, max_rounds=100):
    """IterResearch 完整执行流程"""

    state = IterResearchState(question)

    for round_idx in range(max_rounds):
        # 1. 构建工作空间
        workspace = state.get_workspace()

        # 2. 模型生成：思考 + 更新报告 + 决定动作
        prompt = f"""
{workspace}

请基于上述信息：
1. 在<think>标签中分析当前进展和下一步计划
2. 在<report>标签中更新研究报告（整合新信息，移除无关内容）
3. 在<action>标签中决定下一步动作

如果信息足够回答问题，使用 final_answer 动作。
"""

        output = model.generate(prompt)

        # 3. 解析输出
        think = extract_tag(output, "think")
        new_report = extract_tag(output, "report")
        action = extract_tag(output, "action")

        # 4. 检查是否完成
        if action.type == "final_answer":
            return {
                "answer": action.content,
                "report": new_report,
                "rounds": round_idx + 1
            }

        # 5. 执行动作，获取观察结果
        observation = tools.execute(action)

        # 6. 状态转移（关键：丢弃think，只保留report）
        state.transition(
            think=think,  # 不保存到状态
            new_report=new_report,
            action=action,
            observation=observation
        )

    # 达到最大轮数，返回当前报告
    return {
        "answer": state.report,
        "report": state.report,
        "rounds": max_rounds,
        "status": "max_rounds_reached"
    }
```

### 1.4 其他Agent框架

除了ReAct和IterResearch，还有一些值得了解的框架：

#### 1.4.1 ReWOO (Reasoning WithOut Observation)

先完成所有规划，再批量执行：

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              ReWOO 框架                                          │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  阶段1: 规划 (一次性生成所有计划)                                                │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  Plan: search("query1") → #E1                                           │   │
│  │  Plan: search("query2") → #E2                                           │   │
│  │  Plan: visit(#E1.url) → #E3                                             │   │
│  │  Plan: combine(#E1, #E2, #E3) → Answer                                   │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  阶段2: 执行 (批量执行所有计划)                                                  │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  Execute #E1, #E2 → 得到结果                                             │   │
│  │  Execute #E3 (使用#E1的结果) → 得到结果                                   │   │
│  │  Combine all results → Final Answer                                      │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  优点: 减少LLM调用次数，提高效率                                                │
│  缺点: 无法根据中间结果动态调整                                                 │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

#### 1.4.2 Reflexion

引入自我反思机制：

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                            Reflexion 框架                                        │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  Trial 1: ReAct执行 → 失败                                                      │
│      ↓                                                                          │
│  Reflect: "我搜索的关键词太宽泛了，应该更具体"                                   │
│      ↓                                                                          │
│  Trial 2: ReAct执行(带反思记忆) → 失败                                          │
│      ↓                                                                          │
│  Reflect: "我忘记检查信息的时效性了"                                             │
│      ↓                                                                          │
│  Trial 3: ReAct执行(带累积反思) → 成功                                          │
│                                                                                 │
│  优点: 从失败中学习，提高成功率                                                  │
│  缺点: 需要多次尝试，成本较高                                                    │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

#### 1.4.3 框架选择建议

| 任务特点 | 推荐框架 | 理由 |
|----------|----------|------|
| 简单、步数少 (<10步) | ReAct | 简单直接，overhead小 |
| 复杂、步数多 (10-100步) | IterResearch | 避免上下文溢出 |
| 计划可预知 | ReWOO | 效率高 |
| 允许多次尝试 | Reflexion | 可以从错误中学习 |
| 需要高可靠性 | IterResearch + 并行采样 | 多路径提高成功率 |

---

## 2. 工具集设计

### 2.1 工具设计原则

好的工具设计是Agent成功的关键：

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           工具设计原则                                           │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  原则1: 单一职责                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  ✓ search: 只负责搜索，返回搜索结果                                      │   │
│  │  ✓ visit: 只负责访问网页，返回网页内容                                   │   │
│  │  ✗ search_and_summarize: 职责混合，难以调试                              │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  原则2: 输入输出明确                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  输入: 结构化参数，有明确类型和约束                                       │   │
│  │  输出: 结构化结果，格式一致可预测                                         │   │
│  │  示例: search(query: str, max_results: int = 10) → List[SearchResult]    │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  原则3: 幂等性                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  相同输入应产生相同（或等价）输出                                         │   │
│  │  便于训练（确定性环境）和调试（可复现）                                   │   │
│  │  实现: 结果缓存、固定随机种子                                             │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  原则4: 优雅降级                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  网络超时 → 返回"暂时无法访问，请稍后重试"                                │   │
│  │  页面不存在 → 返回"页面不存在"                                            │   │
│  │  而不是抛出异常导致整个流程崩溃                                           │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  原则5: 输出限制                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  限制输出长度，避免单个观察结果占用过多上下文                              │   │
│  │  search: 每个结果200字以内，最多10个结果                                  │   │
│  │  visit: 总输出4000字以内                                                  │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 核心工具实现

#### 2.2.1 Search 工具

**功能**：调用搜索引擎，返回相关网页列表

```python
from dataclasses import dataclass
from typing import List, Optional
import requests

@dataclass
class SearchResult:
    title: str
    url: str
    snippet: str

class SearchTool:
    """搜索工具实现"""

    def __init__(self, config: dict):
        self.api_key = config["api_key"]
        self.search_engine = config.get("engine", "google")  # google, bing, serper
        self.max_results = config.get("max_results", 10)
        self.timeout = config.get("timeout", 10)

    def __call__(self, query: str,
                 filter_year: Optional[int] = None,
                 site: Optional[str] = None) -> List[SearchResult]:
        """
        执行搜索

        Args:
            query: 搜索查询
            filter_year: 过滤特定年份的结果
            site: 限制搜索特定网站 (如 site:wikipedia.org)

        Returns:
            搜索结果列表
        """
        # 构建完整查询
        full_query = query
        if filter_year:
            full_query += f" {filter_year}"
        if site:
            full_query += f" site:{site}"

        try:
            # 调用搜索API（以Serper为例）
            response = requests.post(
                "https://google.serper.dev/search",
                headers={"X-API-KEY": self.api_key},
                json={"q": full_query, "num": self.max_results},
                timeout=self.timeout
            )
            response.raise_for_status()
            data = response.json()

            results = []
            for item in data.get("organic", [])[:self.max_results]:
                results.append(SearchResult(
                    title=item.get("title", ""),
                    url=item.get("link", ""),
                    snippet=item.get("snippet", "")[:200]  # 限制摘要长度
                ))

            return results

        except requests.Timeout:
            return [SearchResult(
                title="搜索超时",
                url="",
                snippet="搜索请求超时，请稍后重试或尝试不同的查询"
            )]
        except Exception as e:
            return [SearchResult(
                title="搜索失败",
                url="",
                snippet=f"搜索遇到错误: {str(e)}"
            )]

    def format_output(self, results: List[SearchResult]) -> str:
        """格式化输出供模型阅读"""
        if not results:
            return "没有找到相关结果。"

        output = []
        for i, r in enumerate(results, 1):
            output.append(f"{i}. {r.title}")
            output.append(f"   URL: {r.url}")
            output.append(f"   {r.snippet}")
            output.append("")

        return "\n".join(output)
```

#### 2.2.2 Visit 工具

**功能**：访问网页并提取与目标相关的信息

```python
from bs4 import BeautifulSoup
import trafilatura

class VisitTool:
    """网页访问工具实现"""

    def __init__(self, config: dict):
        self.summarizer = config.get("summarizer")  # 摘要模型
        self.max_content_length = config.get("max_content_length", 50000)
        self.max_output_length = config.get("max_output_length", 4000)
        self.timeout = config.get("timeout", 30)
        self.use_jina = config.get("use_jina", True)

    def __call__(self, url: str, goal: str) -> str:
        """
        访问网页并提取相关信息

        Args:
            url: 要访问的网页URL
            goal: 提取信息的目标（如"了解公司的财务状况"）

        Returns:
            与目标相关的信息摘要
        """
        try:
            # 方式1: 使用Jina Reader（推荐）
            if self.use_jina:
                content = self._fetch_with_jina(url)
            else:
                # 方式2: 直接爬取
                content = self._fetch_direct(url)

            if not content:
                return f"无法获取网页内容: {url}"

            # 如果内容太长，使用摘要模型提取相关信息
            if len(content) > self.max_output_length:
                content = self._summarize(content, goal)

            return content[:self.max_output_length]

        except Exception as e:
            return f"访问网页失败: {str(e)}"

    def _fetch_with_jina(self, url: str) -> str:
        """使用Jina Reader获取网页内容"""
        jina_url = f"https://r.jina.ai/{url}"
        response = requests.get(
            jina_url,
            headers={"Accept": "text/plain"},
            timeout=self.timeout
        )
        return response.text[:self.max_content_length]

    def _fetch_direct(self, url: str) -> str:
        """直接爬取网页内容"""
        response = requests.get(url, timeout=self.timeout)

        # 使用trafilatura提取正文
        content = trafilatura.extract(response.text)
        if content:
            return content[:self.max_content_length]

        # 降级：使用BeautifulSoup
        soup = BeautifulSoup(response.text, 'html.parser')
        # 移除脚本和样式
        for tag in soup(['script', 'style', 'nav', 'footer', 'header']):
            tag.decompose()

        text = soup.get_text(separator='\n', strip=True)
        return text[:self.max_content_length]

    def _summarize(self, content: str, goal: str) -> str:
        """使用摘要模型提取相关信息"""
        if not self.summarizer:
            # 没有摘要模型，简单截断
            return content[:self.max_output_length]

        prompt = f"""请从以下网页内容中提取与"{goal}"相关的信息。
只保留相关的关键信息，忽略无关内容。

网页内容:
{content[:self.max_content_length]}

相关信息摘要:"""

        summary = self.summarizer.generate(prompt)
        return summary
```

#### 2.2.3 Scholar 工具

**功能**：搜索学术文献，获取论文元数据

```python
class ScholarTool:
    """学术搜索工具实现"""

    def __init__(self, config: dict):
        self.api_key = config.get("semantic_scholar_api_key")
        self.max_results = config.get("max_results", 10)

    def __call__(self, query: str,
                 year_from: Optional[int] = None,
                 year_to: Optional[int] = None) -> str:
        """
        搜索学术文献

        Args:
            query: 搜索查询
            year_from: 起始年份
            year_to: 结束年份

        Returns:
            论文列表的格式化输出
        """
        try:
            # 使用Semantic Scholar API
            params = {
                "query": query,
                "limit": self.max_results,
                "fields": "title,authors,year,abstract,citationCount,url"
            }

            if year_from or year_to:
                year_filter = ""
                if year_from:
                    year_filter += f"{year_from}-"
                else:
                    year_filter += "-"
                if year_to:
                    year_filter += str(year_to)
                params["year"] = year_filter

            response = requests.get(
                "https://api.semanticscholar.org/graph/v1/paper/search",
                params=params,
                headers={"x-api-key": self.api_key} if self.api_key else {},
                timeout=10
            )
            response.raise_for_status()
            data = response.json()

            return self._format_results(data.get("data", []))

        except Exception as e:
            return f"学术搜索失败: {str(e)}"

    def _format_results(self, papers: list) -> str:
        """格式化论文结果"""
        if not papers:
            return "没有找到相关学术文献。"

        output = []
        for i, paper in enumerate(papers, 1):
            authors = ", ".join([a.get("name", "") for a in paper.get("authors", [])][:3])
            if len(paper.get("authors", [])) > 3:
                authors += " et al."

            output.append(f"{i}. {paper.get('title', 'Unknown Title')}")
            output.append(f"   作者: {authors}")
            output.append(f"   年份: {paper.get('year', 'Unknown')}")
            output.append(f"   引用数: {paper.get('citationCount', 0)}")

            abstract = paper.get("abstract", "")
            if abstract:
                output.append(f"   摘要: {abstract[:200]}...")

            output.append("")

        return "\n".join(output)
```

#### 2.2.4 Python 工具

**功能**：执行Python代码，用于数值计算和数据处理

```python
import subprocess
import tempfile
import os

class PythonTool:
    """Python代码执行工具"""

    def __init__(self, config: dict):
        self.timeout = config.get("timeout", 30)
        self.max_output_length = config.get("max_output_length", 2000)
        self.allowed_modules = config.get("allowed_modules", [
            "math", "statistics", "datetime", "json", "re",
            "collections", "itertools", "functools"
        ])

    def __call__(self, code: str) -> str:
        """
        执行Python代码

        Args:
            code: 要执行的Python代码

        Returns:
            执行结果或错误信息
        """
        # 安全检查
        if not self._is_safe(code):
            return "代码包含不允许的操作（如文件系统访问、网络请求等）"

        try:
            # 创建临时文件
            with tempfile.NamedTemporaryFile(
                mode='w', suffix='.py', delete=False
            ) as f:
                f.write(code)
                temp_file = f.name

            try:
                # 执行代码
                result = subprocess.run(
                    ['python', temp_file],
                    capture_output=True,
                    text=True,
                    timeout=self.timeout
                )

                output = result.stdout
                if result.stderr:
                    output += f"\n错误: {result.stderr}"

                return output[:self.max_output_length]

            finally:
                os.unlink(temp_file)

        except subprocess.TimeoutExpired:
            return "代码执行超时"
        except Exception as e:
            return f"代码执行失败: {str(e)}"

    def _is_safe(self, code: str) -> bool:
        """检查代码是否安全"""
        dangerous_patterns = [
            "import os", "import sys", "import subprocess",
            "open(", "exec(", "eval(",
            "__import__", "importlib",
            "requests", "urllib", "socket"
        ]

        code_lower = code.lower()
        for pattern in dangerous_patterns:
            if pattern.lower() in code_lower:
                return False

        return True
```

### 2.3 工具调用接口设计

统一的工具调用接口便于管理和扩展：

```python
from typing import Dict, Any, Callable
from abc import ABC, abstractmethod

class BaseTool(ABC):
    """工具基类"""

    @property
    @abstractmethod
    def name(self) -> str:
        """工具名称"""
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """工具描述，供模型理解"""
        pass

    @property
    @abstractmethod
    def parameters(self) -> Dict[str, Any]:
        """参数定义，JSON Schema格式"""
        pass

    @abstractmethod
    def __call__(self, **kwargs) -> str:
        """执行工具"""
        pass


class ToolRegistry:
    """工具注册中心"""

    def __init__(self):
        self.tools: Dict[str, BaseTool] = {}
        self.cache = LRUCache(maxsize=10000)

    def register(self, tool: BaseTool):
        """注册工具"""
        self.tools[tool.name] = tool

    def get_tool_descriptions(self) -> str:
        """获取所有工具的描述，用于系统提示"""
        descriptions = []
        for name, tool in self.tools.items():
            descriptions.append(f"- {name}: {tool.description}")
            descriptions.append(f"  参数: {tool.parameters}")
        return "\n".join(descriptions)

    def execute(self, tool_call: Dict[str, Any]) -> str:
        """执行工具调用"""
        name = tool_call["name"]
        args = tool_call.get("arguments", {})

        if name not in self.tools:
            return f"未知工具: {name}"

        # 检查缓存
        cache_key = f"{name}:{json.dumps(args, sort_keys=True)}"
        if cache_key in self.cache:
            return self.cache[cache_key]

        # 执行工具
        try:
            result = self.tools[name](**args)
            self.cache[cache_key] = result
            return result
        except Exception as e:
            return f"工具执行错误: {str(e)}"
```

### 2.4 工具Schema示例

完整的工具定义，便于模型理解如何调用：

```json
{
  "tools": [
    {
      "name": "search",
      "description": "搜索互联网获取相关信息。当你需要查找事实、数据、新闻或任何网上可找到的信息时使用此工具。",
      "parameters": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "搜索查询词。应该简洁、具体，包含关键词。"
          },
          "filter_year": {
            "type": "integer",
            "description": "可选。过滤特定年份的结果。"
          }
        },
        "required": ["query"]
      }
    },
    {
      "name": "visit",
      "description": "访问网页并提取相关信息。当你需要获取特定网页的详细内容时使用此工具。",
      "parameters": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "要访问的网页URL"
          },
          "goal": {
            "type": "string",
            "description": "你想从这个网页中获取什么信息"
          }
        },
        "required": ["url", "goal"]
      }
    },
    {
      "name": "scholar",
      "description": "搜索学术文献和论文。当你需要查找研究论文、学术观点或科学数据时使用此工具。",
      "parameters": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "学术搜索查询"
          },
          "year_from": {
            "type": "integer",
            "description": "可选。论文发表的起始年份"
          },
          "year_to": {
            "type": "integer",
            "description": "可选。论文发表的结束年份"
          }
        },
        "required": ["query"]
      }
    },
    {
      "name": "python",
      "description": "执行Python代码进行计算。当你需要进行数学计算、数据处理或分析时使用此工具。",
      "parameters": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": "要执行的Python代码。代码应该打印出结果。"
          }
        },
        "required": ["code"]
      }
    },
    {
      "name": "final_answer",
      "description": "当你已经收集到足够的信息来回答问题时，使用此工具提供最终答案。",
      "parameters": {
        "type": "object",
        "properties": {
          "answer": {
            "type": "string",
            "description": "对用户问题的完整回答"
          }
        },
        "required": ["answer"]
      }
    }
  ]
}
```

---

## 3. 状态管理与记忆机制

### 3.1 上下文管理策略

长任务的上下文管理是Deep Research的核心挑战：

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                        上下文管理策略对比                                        │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  策略1: 完整保留 (ReAct默认)                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  保留所有历史 Think, Action, Observation                                 │   │
│  │  优点: 信息完整，不丢失细节                                              │   │
│  │  缺点: 上下文快速膨胀，长任务不可行                                       │   │
│  │  适用: 短任务 (<10步)                                                    │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  策略2: 滑动窗口                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  只保留最近K步的历史                                                      │   │
│  │  优点: 上下文大小有界                                                     │   │
│  │  缺点: 丢失早期重要信息                                                   │   │
│  │  适用: 局部依赖的任务                                                     │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  策略3: 动态摘要 (ReSum)                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  当上下文达到阈值时，调用摘要工具压缩历史                                  │   │
│  │  优点: 保留关键信息，控制上下文大小                                       │   │
│  │  缺点: 摘要可能丢失细节，增加计算成本                                     │   │
│  │  适用: 中等复杂度任务                                                     │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  策略4: 演进报告 (IterResearch)                                                  │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  每轮更新结构化报告，丢弃临时信息                                         │   │
│  │  优点: 常量大小上下文，支持无限深度                                       │   │
│  │  缺点: 需要模型学会有效更新报告                                           │   │
│  │  适用: 深度研究任务                                                       │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 ReSum 动态摘要机制

ReSum 在上下文即将溢出时触发摘要：

```python
class ReSumContextManager:
    """ReSum上下文管理器"""

    def __init__(self, config: dict):
        self.max_tokens = config.get("max_tokens", 32000)
        self.trigger_threshold = config.get("trigger_threshold", 0.9)
        self.summarizer = config["summarizer"]
        self.tokenizer = config["tokenizer"]

    def should_summarize(self, messages: list) -> bool:
        """检查是否需要摘要"""
        current_tokens = self._count_tokens(messages)
        return current_tokens > self.max_tokens * self.trigger_threshold

    def summarize(self, messages: list, question: str) -> list:
        """执行摘要，返回压缩后的消息列表"""
        # 提取历史内容
        history_content = self._extract_history(messages)

        # 生成摘要
        summary_prompt = f"""请将以下研究历史压缩为一个简洁的摘要，保留：
1. 关键发现和事实
2. 已验证的信息来源
3. 尚未解决的问题

原始问题: {question}

研究历史:
{history_content}

请生成结构化摘要:"""

        summary = self.summarizer.generate(summary_prompt)

        # 构建新的消息列表
        new_messages = [
            {"role": "user", "content": f"{question}\n\n<previous_research_summary>\n{summary}\n</previous_research_summary>"}
        ]

        return new_messages

    def _count_tokens(self, messages: list) -> int:
        """统计token数量"""
        total = 0
        for msg in messages:
            total += len(self.tokenizer.encode(msg["content"]))
        return total

    def _extract_history(self, messages: list) -> str:
        """提取历史内容"""
        history = []
        for msg in messages:
            role = msg["role"]
            content = msg["content"]
            history.append(f"[{role}]: {content}")
        return "\n\n".join(history)
```

### 3.3 外部记忆系统

对于需要处理大量信息的场景，可以引入外部记忆系统：

```python
from typing import List, Tuple
import numpy as np

class ExternalMemory:
    """外部向量记忆系统"""

    def __init__(self, config: dict):
        self.embedding_model = config["embedding_model"]
        self.dimension = config.get("dimension", 1024)
        self.max_entries = config.get("max_entries", 1000)

        self.memories: List[Tuple[str, np.ndarray]] = []

    def add(self, content: str, metadata: dict = None):
        """添加记忆条目"""
        embedding = self._embed(content)

        entry = {
            "content": content,
            "embedding": embedding,
            "metadata": metadata or {},
            "timestamp": time.time()
        }

        self.memories.append(entry)

        # 如果超过限制，移除最旧的条目
        if len(self.memories) > self.max_entries:
            self.memories = self.memories[-self.max_entries:]

    def retrieve(self, query: str, top_k: int = 5) -> List[str]:
        """检索相关记忆"""
        if not self.memories:
            return []

        query_embedding = self._embed(query)

        # 计算相似度
        similarities = []
        for entry in self.memories:
            sim = self._cosine_similarity(query_embedding, entry["embedding"])
            similarities.append((sim, entry["content"]))

        # 返回top-k
        similarities.sort(key=lambda x: x[0], reverse=True)
        return [content for _, content in similarities[:top_k]]

    def _embed(self, text: str) -> np.ndarray:
        """生成文本嵌入"""
        return self.embedding_model.encode(text)

    def _cosine_similarity(self, a: np.ndarray, b: np.ndarray) -> float:
        """计算余弦相似度"""
        return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))
```

---

## 4. 系统提示设计

### 4.1 系统提示的重要性

系统提示定义了Agent的行为边界和风格：

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                        系统提示的作用                                            │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  1. 定义角色和能力                                                               │
│     "你是一个深度研究助手，能够使用搜索和浏览工具..."                             │
│                                                                                 │
│  2. 规定输出格式                                                                 │
│     "请使用<think>标签进行推理，<tool_call>标签调用工具..."                       │
│                                                                                 │
│  3. 设定行为准则                                                                 │
│     "不要猜测搜索结果，必须实际执行搜索..."                                       │
│                                                                                 │
│  4. 提供示例                                                                     │
│     "以下是一个示范交互..."                                                      │
│                                                                                 │
│  5. 控制推理深度                                                                 │
│     "在信息足够时立即给出答案，不要过度搜索..."                                   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 系统提示模板

**ReAct模式系统提示**：

```
你是一个专业的深度研究助手，能够通过多轮搜索和分析来回答复杂问题。

## 可用工具

{tool_descriptions}

## 输出格式

每次回复请按以下格式：

1. 首先在<think>标签中分析当前状态和计划：
   - 已知什么信息
   - 还需要什么信息
   - 下一步应该做什么

2. 然后在<tool_call>标签中调用工具（如果需要）：
   ```json
   {"name": "工具名", "arguments": {"参数名": "参数值"}}
   ```

3. 如果信息足够，在<answer>标签中给出最终答案。

## 行为准则

1. **不要猜测**：不确定的信息必须搜索确认
2. **验证信息**：重要事实尽量从多个来源验证
3. **注明来源**：答案中应包含信息来源
4. **保持专注**：围绕问题核心，不要偏离主题
5. **适时停止**：信息足够时立即回答，不要过度搜索

## 示例

用户: 特斯拉2024年的全球交付量是多少？

<think>
用户询问特斯拉2024年的交付数据。这是一个需要最新数据的问题，
我需要搜索特斯拉2024年的官方交付数据。
</think>
<tool_call>
{"name": "search", "arguments": {"query": "Tesla 2024 global deliveries official"}}
</tool_call>
```

**IterResearch模式系统提示**：

```
你是一个专业的深度研究助手，使用迭代研究方法来回答复杂问题。

## 核心机制

你维护一份"研究报告"，每轮更新。这份报告是你的中央记忆，
包含了所有重要发现。每轮结束后，临时信息会被丢弃，只保留报告。

## 可用工具

{tool_descriptions}

## 每轮输出格式

1. **思考** <think>: 分析当前进展，规划下一步
2. **更新报告** <report>: 整合新信息到报告中
3. **执行动作** <action>: 调用工具或给出最终答案

## 报告结构

<report>
## 研究进展

### 已确认信息
- [信息1]: [来源]
- [信息2]: [来源]

### 待验证信息
- [待验证点]

### 信息缺口
- [还需要了解的内容]

### 当前结论
[基于已有信息的初步结论]
</report>

## 行为准则

1. 每轮都要更新报告，不要遗漏重要发现
2. 从报告中移除已被证伪或不相关的信息
3. 当报告中的信息足以回答问题时，使用final_answer
4. 报告应保持简洁，避免冗余
```

---

## 5. 错误处理与容错机制

### 5.1 常见错误类型

| 错误类型 | 表现 | 原因 | 处理策略 |
|----------|------|------|----------|
| **格式错误** | 工具调用JSON格式不正确 | 模型输出不规范 | 重试或格式修复 |
| **工具调用失败** | 搜索超时、网页无法访问 | 网络问题、服务不可用 | 重试或优雅降级 |
| **无限循环** | 重复相同的搜索查询 | 策略陷入局部最优 | 检测并强制终止 |
| **幻觉** | 编造搜索结果或信息 | 模型生成倾向 | 格式约束、验证机制 |
| **上下文溢出** | 历史太长无法处理 | 任务步数过多 | 摘要或截断 |

### 5.2 容错实现

```python
class RobustAgentExecutor:
    """健壮的Agent执行器"""

    def __init__(self, config: dict):
        self.model = config["model"]
        self.tools = config["tools"]
        self.max_retries = config.get("max_retries", 3)
        self.max_steps = config.get("max_steps", 50)
        self.loop_detector = LoopDetector(window_size=5)

    def execute(self, question: str) -> dict:
        """执行Agent任务"""
        messages = [{"role": "user", "content": question}]

        for step in range(self.max_steps):
            try:
                # 1. 生成响应（带重试）
                response = self._generate_with_retry(messages)

                # 2. 解析响应
                parsed = self._parse_response(response)

                # 3. 检查是否完成
                if parsed.get("is_final"):
                    return {"answer": parsed["answer"], "steps": step + 1}

                # 4. 检查循环
                if self.loop_detector.is_loop(parsed.get("action")):
                    response = self._handle_loop(messages)
                    parsed = self._parse_response(response)

                # 5. 执行工具
                observation = self._execute_tool_with_fallback(parsed["action"])

                # 6. 更新消息历史
                messages.append({"role": "assistant", "content": response})
                messages.append({"role": "user", "content": f"<tool_response>{observation}</tool_response>"})

            except Exception as e:
                # 记录错误并尝试恢复
                messages.append({
                    "role": "user",
                    "content": f"<system_error>发生错误: {str(e)}。请调整策略继续。</system_error>"
                })

        return {"answer": "达到最大步数限制", "steps": self.max_steps, "status": "incomplete"}

    def _generate_with_retry(self, messages: list) -> str:
        """带重试的生成"""
        last_error = None
        for attempt in range(self.max_retries):
            try:
                response = self.model.generate(messages)
                # 验证响应格式
                if self._is_valid_format(response):
                    return response
            except Exception as e:
                last_error = e
                time.sleep(2 ** attempt)  # 指数退避

        raise Exception(f"生成失败，重试{self.max_retries}次后仍然失败: {last_error}")

    def _execute_tool_with_fallback(self, action: dict) -> str:
        """带降级的工具执行"""
        try:
            result = self.tools.execute(action)
            return result
        except TimeoutError:
            return "工具调用超时。请尝试其他方法或稍后重试。"
        except Exception as e:
            return f"工具调用失败: {str(e)}。请尝试其他方法。"

    def _handle_loop(self, messages: list) -> str:
        """处理循环"""
        # 添加提示让模型跳出循环
        messages.append({
            "role": "user",
            "content": "<system_hint>检测到你可能陷入循环，请尝试不同的搜索策略或根据已有信息给出答案。</system_hint>"
        })
        return self.model.generate(messages)


class LoopDetector:
    """循环检测器"""

    def __init__(self, window_size: int = 5, threshold: float = 0.8):
        self.window_size = window_size
        self.threshold = threshold
        self.recent_actions = []

    def is_loop(self, action: dict) -> bool:
        """检测是否进入循环"""
        action_str = json.dumps(action, sort_keys=True)

        self.recent_actions.append(action_str)
        if len(self.recent_actions) > self.window_size:
            self.recent_actions = self.recent_actions[-self.window_size:]

        if len(self.recent_actions) < 3:
            return False

        # 检查重复率
        unique_actions = set(self.recent_actions)
        repetition_rate = 1 - len(unique_actions) / len(self.recent_actions)

        return repetition_rate > self.threshold
```

---

## 6. 总结

本模块详细介绍了Deep Research Agent的系统架构设计：

### 关键要点回顾

1. **Agent框架选择**
   - ReAct：简单任务的首选，直观易实现
   - IterResearch：复杂任务的首选，支持无限深度

2. **工具设计原则**
   - 单一职责、输入输出明确、幂等性、优雅降级

3. **核心工具**
   - Search：搜索引擎接入
   - Visit：网页内容提取
   - Scholar：学术文献搜索
   - Python：代码执行

4. **上下文管理**
   - 完整保留、滑动窗口、动态摘要、演进报告各有适用场景

5. **容错机制**
   - 重试策略、循环检测、优雅降级

### 实践建议

| 场景 | 推荐配置 |
|------|----------|
| 快速原型 | ReAct + Search + Visit |
| 生产系统 | IterResearch + 完整工具集 + 容错机制 |
| 学术研究 | IterResearch + Scholar + 外部记忆 |
| 高可靠性要求 | 并行采样 + 结果综合 |

在下一模块中，我们将详细介绍如何构造高质量的训练数据。
